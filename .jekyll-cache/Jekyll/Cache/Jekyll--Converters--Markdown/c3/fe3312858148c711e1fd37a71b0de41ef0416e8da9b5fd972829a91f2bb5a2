I"ö&<p>ä½¿ç”¨é¡µè¡¨çš„å¥½å¤„åœ¨äºå®ç°è¿›ç¨‹ä¹‹é—´çš„éš”ç¦»
éš”ç¦»çš„å¥½å¤„åœ¨äºé˜²æ­¢å› æ„å¤–æˆ–è€…æ¶æ„å¯¼è‡´çš„è¿›ç¨‹ç»ˆæ­¢å½±å“åˆ°å…¶ä»–çš„è¿›ç¨‹ç”šè‡³å†…æ ¸</p>

<p>åœ°å€ç©ºé—´ address space
åœ°å€ç©ºé—´çš„ç›®çš„åœ¨äºç»™æ¯ä¸ªè¿›ç¨‹åŒ…æ‹¬å†…æ ¸kernelä¸€ä¸ªç‹¬ç«‹çš„å†…å­˜ï¼ˆé€»è¾‘ä¸Šç‹¬å ä¸€å—å†…å­˜ï¼‰</p>

<p>è™šåœ°å€ç©ºé—´å¯èƒ½æ¯”å®åœ°å€ç©ºé—´æ›´å¤§ä¹Ÿå¯èƒ½æ›´å°</p>

<p>è™šåœ°å€ä»é€»è¾‘ä¸Šå®ç°äº†ï¼ˆå®åœ°å€ï¼‰å†…å­˜çš„å¤ç”¨
å¤šä¸ªè¿›ç¨‹å…±ç”¨ä¸€å—å†…å­˜ï¼ˆåŒæ ·è¿›ç¨‹å¤ç”¨çš„è¿˜æœ‰å¤„ç†å™¨ï¼‰
æœ€å¸¸ç”¨çš„å†…å­˜å¤ç”¨çš„æ–¹æ³•å°±æ˜¯é¡µè¡¨</p>

<p>é¡µè¡¨ç”±ç¡¬ä»¶å®ç°ï¼Œå³Memory management unitï¼ˆMMUï¼‰
å¦‚æœmmuåŠŸèƒ½å¼€å¯çš„è¯ï¼ŒCPUé€šè¿‡MMUå°†è™šåœ°å€è½¬æ¢ä¸ºå®åœ°å€
MMUæ§åˆ¶é¡µè¡¨</p>

<p>é¡µè¡¨åŒæ ·å­˜å‚¨åœ¨å†…å­˜ä¸­
åŒæ—¶ç”¨ä¸€ä¸ªå¯„å­˜å™¨å­˜å‚¨ç€é¡µè¡¨åœ¨å†…å­˜ä¸­çš„åœ°å€
ï¼ˆA register stores where the page table storesï¼‰</p>

<p>Every application/process has its own map and that map defines its address space.
åœ¨RISC-Vä¸­å¯„å­˜å™¨satpå­˜å‚¨ç€é¡µè¡¨åœ¨å†…å­˜ä¸­çš„åœ°å€
å½“CPUæˆ–è€…è¯´æ“ä½œç³»ç»Ÿè¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼ˆcontext switchï¼‰çš„æ—¶å€™ 
satpå¯„å­˜å™¨ä¸­çš„å€¼ä¹Ÿå°†è¢«æ›¿æ¢ä¸ºæ–°çš„è¿›ç¨‹çš„é¡µè¡¨çš„åœ°å€</p>

<p>RISC-VæŒ‡ä»¤é›†çš„é¡µè¡¨å¤§å°ä¸º4kBï¼ˆ4096 bytesï¼‰
å¯»å€æ‰€ç”¨åˆ°çš„ä½æ•°ä¸º39ä½ï¼ˆå®é™…ä½¿ç”¨çš„æ˜¯38ä½ï¼Œå¯¹åº”256GBå¤§å°çš„å†…å­˜ï¼‰</p>

<p>åœ¨RISC-Vä¸­ï¼Œä¸€ä¸ªè™šåœ°å€ï¼ˆ64ä½ï¼‰ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œå‰25ä½ä¸ºä¿ç•™ä½
å®é™…ä½¿ç”¨çš„æ˜¯å39ä½ï¼Œå…¶ä¸­å‰27ä½ä¸ºindexï¼Œç”¨äºç´¢å¼•physical page number
å12ä½æ˜¯offset
å³å®é™…ç”¨äºç´¢å¼•é¡µè¡¨çš„æ˜¯indexï¼Œindexå¯ä»¥ç´¢å¼•åˆ°æŸä¸€å¼ å…·ä½“çš„é¡µè¡¨
offsetæ ¹æ®è¢«ç´¢å¼•çš„é¡µè¡¨æ¥ç¡®å®šå®åœ°å€ä¸­çš„å…·ä½“ä½ç½®</p>

<p>A page table is stored in physical memory as a three-level tree.
Questionï¼š
â€œIs it just me? why use 3 level page table? I still didnâ€™t see the point.â€
â€œI think itâ€™s because when using a single page table, 
you always have to allocate memory for the entire table of size 2^27,
but the 3 level organization allows you to create a few small page directories if the process need a little memory.â€
é¡µè¡¨ç´¢å¼•åˆ†çº§çš„ä¸€ä¸ªå¯èƒ½åŸå› æ˜¯æé«˜æ•ˆç‡ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹ä¸éœ€è¦å¾ˆå¤šçš„å†…å­˜
é‚£ä¹ˆå®Œå…¨å¯ä»¥åªå»ºç«‹å°çš„ç´¢å¼•ç”¨ä»¥æé«˜ç´¢å¼•çš„æ•ˆç‡</p>

<p>æŒ‡ä»¤é›†ä¸º64ä½çš„æ„æ€æ˜¯å…¶åœ°å€ç”¨64ä½è¡¨ç¤ºï¼š
å†…å­˜ä¸­çš„åœ°å€æœ€å¤§å¯ä»¥æ˜¯2çš„64æ¬¡æ–¹ï¼ŒåŒæ—¶ä¸€ä¸ªå¯„å­˜å™¨ï¼ˆå­˜æ”¾åœ°å€ï¼‰æ˜¯64ä½ã€‚
RISC-V æŒ‡ä»¤é›†æœ‰64ä¸ªå¯„å­˜å™¨ï¼Œ32ä¸ªæ•´æ•°å¯„å­˜å™¨ï¼Œ32ä¸ªæµ®ç‚¹æ•°å¯„å­˜å™¨ã€‚</p>

<p>åœ¨RISV-Vä¸­ï¼Œä¸€ä¸ªå®åœ°å€çš„å¤§å°ä½56ä½
56ä½è¿™ä¸ªå¤§å°æ˜¯ç”±ç¡¬ä»¶è®¾è®¡è€…å†³å®šçš„ï¼ˆä¸»æ¿åŸåˆ™ä¸Šèƒ½å¤Ÿæ”¯æŒ56ä½å¤§å°çš„ç‰©ç†å†…å­˜ ï¼‰
è¿™æ„å‘³ç€å®é™…å¯»å€åªè¦ç”¨åˆ°56æ ¹åœ°å€çº¿è€Œä¸æ˜¯64æ ¹
å³å®åœ°å€çš„å¤§å°è¿œè¿œå¤§äºè™šåœ°å€</p>

<p>A RISV-V page table is logically an array of 2^27ï¼ˆ134,217,728ï¼‰page table entries(PTEs)
é¡µè¡¨å°±æ˜¯ä¸€ä¸ªPTEçš„æ•°ç»„
æ¯ä¸€ä¸ªPTEåŒ…å«ä¸€ä¸ª44ä½çš„phisical page numberï¼ˆPPNï¼‰å’Œsome flags.
ä¸€ä¸ªå®åœ°å€å°±æ˜¯ä¸€ä¸ªPPNï¼ˆå‰44ä½ï¼‰+æ¥è‡ªè™šåœ°å€ä¸­çš„offsetï¼ˆ12ä½ï¼‰å…±56ä½</p>

<p>A page table is stored in physical memory as a three-level tree.
é¡µè¡¨ä½œä¸ºä¸€ä¸ªä¸‰çº§æ ‘ç»“æ„å­˜å‚¨åœ¨ç‰©ç†å†…å­˜ä¸­
This three-level structure allows a page table to omit entire page table pages in the common case in which large ranges of virtual addresses have no mappings.
ï¼ˆé€šå¸¸æƒ…å†µä¸‹å¤§éƒ¨åˆ†çš„è™šæ‹Ÿåœ°å€éƒ½æ²¡æœ‰ç›¸åº”çš„æ˜ å°„ï¼Œåˆ†çº§æé«˜äº†åœ°å€è½¬æ¢çš„æ•ˆç‡ï¼‰</p>

<p>Each PTE contains flag bits that tell the paging hardware how the associated virtual address is allowed to be used.
æ¯æ¡PTEåŒ…å«ä¸€äº›æ ‡å¿—ä½ï¼ˆ9ä½ï¼‰ï¼Œç”¨äºæŒ‡ç¤ºMMUå¦‚ä½•ä½¿ç”¨ç›¸åº”çš„è™šæ‹Ÿåœ°å€.</p>

<p>To tell the hardware to use a page table, the kernel must write the physical address of the root page-table page into the satp register
ç¡¬ä»¶å¦‚ä½•è¯†åˆ«/æ‰¾åˆ°é¡µè¡¨ï¼Ÿ
æ ¹é¡µè¡¨é¡µï¼Œå­˜å‚¨åœ¨satpè¿™ä¸ªå¯„å­˜å™¨ä¸­ï¼Œæ¯ä¸ªCPUéƒ½æœ‰ä¸€ä¸ªsatpå¯„å­˜å™¨</p>

<p>Each CPU has its own satp so that different CPUs can run different processes, each with a private address space described by its own page table.
æ¯ä¸ªCPUéƒ½æœ‰è‡ªå·±çš„satpå¯„å­˜å™¨ï¼Œå› æ­¤æ¯ä¸ªCPUéƒ½å¯ä»¥ï¼ˆåŒæ—¶è€Œä¸æ˜¯åˆ†æ—¶ï¼‰è¿è¡Œä¸€ä¸ªç‹¬ç«‹çš„è¿›ç¨‹ï¼Œ
è¿™æ ·çš„æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„åœ°å€ç©ºé—´ï¼ˆåœ°å€ç©ºé—´ç”±é¡µè¡¨å†³å®šï¼‰ã€‚</p>

<p>ç‰©ç†åœ°å€ï¼šstorages cells in DRAM
A few notes about terms. Physical memory refers to storage cells in DRAM. A byte of physical
memory has an address, called a physical address. Instructions use only virtual addresses,
which the paging hardware translates to physical addresses, and then sends to the DRAM hardware to read or write storage.
Virtual memory refers to the collection of abstractions and mechanisms the kernel provides to manage physical memory and virtual addresses.</p>

<p>Kernel address space
The kernel uses an identity mapping for most virtual addresses; that is, most of the kernelâ€™s
address space is â€œdirect-mapped.â€ For example, the kernel itself is located at KERNBASE in both the virtual address space and in physical memory.
å†…æ ¸åœ°å€æ˜¯ç›´æ¥ç›´æ¥å¯¹åº”ï¼ˆæ˜ å°„ï¼‰çš„</p>

<p>There are a couple of virtual addresses that arenâ€™t direct-mapped:
1 The trampoline page. It is mapped at the top of the virtual address space; user page tables
have this same mapping. A physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel: once at top of the virtual address space and once in the kernel text.
2 The kernel stack page. Each process has its own kernel stack,which is mapped high so
that below it xv6 can leave an unmapped guard page. The guard pageâ€™s PTE is invalid (i.e.,
PTE_V is not set), which ensures that if the kernel overflows a kernel stack, it will likely
cause a fault and the kernel will panic.Without a guard page an overflowing stack would
overwrite other kernel memory, resulting in incorrect operation. A panic crash is preferable.</p>

<p>panicæ˜¯å¯æ¥å—çš„ï¼Œè€Œé¿å…äº†å› ä¸ºstack overflowå¯¼è‡´çš„å†…æ ¸å´©æºƒã€‚</p>

<p>guard page:ç”¨äºé˜²æ­¢æ ˆå†…å­˜æº¢å‡ºï¼ˆoverflowï¼‰;å¹¶ä¸”åœ¨å†…å­˜ä¸­æ²¡æœ‰å®åœ°å€æ˜ å°„ï¼ˆmapping invalidï¼‰
The kernel maps the pages for the trampoline and the kernel text with the permissions PTE_R
and PTE_X . The kernel reads and executes instructions from these pages. The kernel maps the other pages with the permissions PTE_R and PTE_W , so that it can read and write the memory in those pages. The mappings for the guard pages are invalid.</p>

<p>kernel virtual address space:
KERNBASE(0x80000000),Kernel text,Kernel data,Free memory,
PHYSTOP(0x86400000),â€¦Kstack1,Guard page,Kstack0,Guard pageï¼ŒTrampoline</p>

<p>Code:creating an address space
Most of the xv6 code for manipulating address spaces and page tables resides in vm.c . The central data structure is pagetable_t, which is really a pointer to a RISC-V root page-table page; a pagetable_t may be either the kernel page table, or one of the per-process page tables. The central functions are walk, which finds the PTE for a virtual address,
and mappages, which installs PTEs for new mappings. Functions starting with kvm manipulate
the kernel page table; functions starting with uvm manipulate a user page table; other functions are used for both. copyout and copyin copy data to and from user virtual addresses provided as system call arguments; they are in vm.c because they need to explicitly translate those addresses in order to find the corresponding physical memory.</p>

<p>pagetable_t æ˜¯ä¸€ä¸ªæŒ‡å‘root page-table pageçš„æŒ‡é’ˆï¼Œå¯èƒ½æ˜¯å†…æ ¸é¡µè¡¨ä¹Ÿå¯èƒ½æ˜¯æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨</p>

<p>Each RISC-V core caches page table entries in a Translation Look-aside Buffer (TLB), and
when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB
entries. If it didnâ€™t, then at some point later the TLB might use an old cached mapping, pointing to a physical page that in the meantime has been allocated to another process, and as a result, a process might be able to scribble on some other processâ€™s memory. The RISC-V has an instruction sfence.vma that flushes the current coreâ€™s TLB. xv6 executes sfence.vma in kvminithart after reloading the satp register, and in the trampoline code that switches to a user page table before returning to user space
æ¯ä¸ªå¤„ç†å™¨éƒ½å°†PTEç¼“å­˜åœ¨TLBä¸­ï¼Œå½“xv6æ›´æ¢ä¸€ä¸ªé¡µè¡¨çš„æ—¶å€™ï¼Œå®ƒå¿…é¡»å‘ŠçŸ¥å¤„ç†å™¨åˆ·æ–°ç›¸åº”çš„TLBç¼“å­˜ã€‚
RISC-Vä½¿ç”¨sfence.vmaæŒ‡ä»¤æ¥åˆ·æ–°å½“å‰å¤„ç†å™¨çš„TLB.
xv6æ‰§è¡Œsfence.vma in kvminithartï¼Œå½“é‡æ–°è£…è½½å®Œsatpå¯„å­˜å™¨ä¹‹åã€‚(å³æ›´æ¢é¡µè¡¨ä¹‹åç«‹å³åˆ·æ–°TLB)</p>

<p>Phisical memory allocation
The kernel must allocate and free physical memory at run-time for page tables, user memory,
kernel stacks, and pipe buffers.
xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time alloca-
tion. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are free by threading a linked list through the pages themselves. Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</p>

<p>Process address space
Each process has a separate page table, and when xv6 switches between processes, it also changes page tables.
A processâ€™s user memory starts at virtual address zero and can grow up to MAXVA, allowing a process to address in principle 256 Gigabytes of memory.</p>

<p>When a process asks xv6 for more user memory, xv6 first uses kalloc to allocate physical
pages. It then adds PTEs to the processâ€™s page table that point to the new physical pages. Xv6 sets the PTE_W , PTE_X , PTE_R , PTE_U , and PTE_V flags in these PTEs. Most processes do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.</p>

<p>åˆ†é…å†…å­˜æ„å‘³ç€ä»€ä¹ˆï¼Ÿ
é¦–å…ˆåˆ†é…ç‰©ç†å†…å­˜ï¼Œç„¶åå°†PTEsæ·»åŠ åˆ°ç›¸åº”è¿›ç¨‹çš„é¡µè¡¨ä¸­ã€‚ï¼ˆPTEsè®¾ç½®ç›¸åº”çš„flagsï¼‰</p>

:ET